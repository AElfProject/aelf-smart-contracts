syntax = "proto3";

import "common.proto";
import "aelf_options.proto";
import "google/protobuf/empty.proto";

option csharp_namespace = "AElf.Contracts.TokenConverter";

service TokenConverterContract {
    option (aelf.csharp_state) = "AElf.Contracts.TokenConverter.TokenConverterContractState";
    // Actions
    rpc Initialize (InitializeInput) returns (google.protobuf.Empty) {
    }
    rpc SetConnector (Connector) returns (google.protobuf.Empty) {
    }
    rpc Buy(BuyInput) returns(google.protobuf.Empty) {
    }
    rpc Sell(SellInput) returns(google.protobuf.Empty) {
    }
    // Views
    rpc GetTokenContractAddress (google.protobuf.Empty) returns (Address) {
        option (aelf.is_view) = true;
    }
    rpc GetFeeReceiverAddress (google.protobuf.Empty) returns (Address) {
        option (aelf.is_view) = true;
    }
    rpc GetConnector (TokenId) returns (Connector) {
        option (aelf.is_view) = true;
    }
}

message Connector {
    string symbol = 1;
    sint64 virtual_balance = 2;
    sint64 weight = 3; // Weight based on MAX of 1,000,000
    bool is_virtual_balance_enabled = 4; // true if virtual balance is enabled, false if not
    bool is_purchase_enabled = 5;
}

message TokenId {
    string symbol = 1;
}

message UserTokenId {
    Address address = 1;
    string symbol = 2;
}

message InitializeInput {
    Address token_contract_address = 1;
    Address fee_receiver_address = 2;
    string base_token_symbol = 3;
    repeated Connector connectors = 4;
    sint64 fee_rate_numerator = 5; // Numerator of fee rate
    sint64 fee_rate_denominator = 6; // Denominator of fee rate
    sint32 max_weight = 7;
    Address manager = 8;
}

message BuyInput {
    string symbol = 1;
    sint64 amount = 2;
    sint64 pay_limit = 3; // No buy if paying more than this, 0 if no limit
}

message SellInput {
    string symbol = 1;
    sint64 amount = 2;
    sint64 receive_limit = 3; // No sell if receiving less than this, 0 if no limit
}
